
# Token Types.
class TT:
  comment = 'comment'
  config = 'config'
  style = 'style'
  slides = 'slides'
  script = 'script'
  slide_title = 'slide title'
  newline = 'newline'
  character = 'simple character'
  include = 'include directive'
  external_script = 'external script'
  begin_center = 'begin centering'
  end_center = 'end centering'
  begin_div = 'begin div'
  begin_list = 'begin list'
  end_group = 'end group'
  media = 'media'
  line_break = 'line break'
  bold = 'bold'
  ital = 'italics'
  item = 'item'
  start = 'start slide'
  vertical_space = 'vertical space'
  inline_math = 'inline math delimiter'
  em_dash = 'em dash'


# A token class.  Mainly useful because it can keep track of a location in the
# input file, for error messages.
class Token:
  def __init__(self, _tt, _text, _filename, _line):
    self.tt = _tt
    self.text = _text
    self.filename = _filename
    self.line = _line

  def complain(self, message):
    complain("%s(%d): %s" % (self.filename, self.line, message))

  def __repr__(self):
    return "Token(%s, %s, %s, %s)" % (self.tt.__repr__(), self.text.__repr__(), self.filename.__repr__(), self.line.__repr__())

def lex(filename, x):
  # Tokenize the input.  The patterns below are a prioritized list of patterns
  # to search for.  We peel off the first matching pattern, and then repeat
  # until nothing is left.  Each pattern can have a () group, which will become
  # the token text.
  patterns = [
    (r'\\(\})', TT.character),
    #(r'(//.*)', TT.comment),
    (r'\[config\]', TT.config),
    (r'\[slides\]', TT.slides),
    (r'\[script\]', TT.script),
    (r'#include (.*)', TT.include),
    (r'#script (.*)', TT.external_script),
    (r'#starthere', TT.start),
    (r'#start', TT.start),
    (r'#{3,}\s*([^#\n]*?)\s*#{3,}', TT.slide_title),
    (r'\[\[([^\]]*)\]\]', TT.media),
    (r'>>>', TT.begin_center),
    (r'<<<', TT.end_center),
    (r'\\\\', TT.line_break),
    (r'\.\.\.', TT.vertical_space),
    (r'--\s+', TT.item),
    (r'!([a-zA-Z_:=0-9\[\];"\'%+-]*){', TT.begin_div),
    (r'@([a-zA-Z]*){', TT.begin_list),
    (r'(})', TT.end_group),
    (r'\*\*', TT.bold),
    (r'__', TT.ital),
    (r'(\n+)', TT.newline),
    (r'(\$)', TT.inline_math),
    (r'(---)', TT.em_dash),
  ]


# These are used to make sure that we opens and closes of various tags are
# matched.
def push_tag(tag, token):
  tag_stack.append((tag, token))

def pop_tag(tag, token):
  (old_tag, old_token) = tag_stack.pop()
  if old_tag != tag:
    token.complain("Closing %s tag mismatches with the opening %s tag from %s(%s)." % (tag, old_tag, old_token.filename, old_token.line))

# These functions are generally used as actions in parse() below.
def append_to_config(token):
  global config_text 
  config_text += token.text

def append_to_style(token):
  global style_text 
  style_text += token.text

def append_to_slides(token):
  global slides_text 
  slides_text += token.text

def append_to_script(token):
  global script_text 
  script_text += token.text


def begin_slide(token):
  global slides_text, slide_number
  slides_text += "<section>"
  slides_text += "<h1>" + token.text + "</h1>"
  push_tag("section", token)
  slides_text += "<center><div class=slide-body>"
  push_tag("slide-body", token)
  slide_number += 1

def end_slide(token=None):
  global slides_text
  slides_text += "</div></center>"
  pop_tag('slide-body', token)
  slides_text += "</section>"
  pop_tag('section', token)

def set_start_slide(token):
  global start_slide_number
  start_slide_number = slide_number - 1

def end_and_begin_slide(token):
  end_slide(token)
  begin_slide(token)

def begin_center(token):
  global slides_text
  slides_text += "<div style='text-align: center'>"
  push_tag('center', token)
  
def end_center(token):
  global slides_text
  slides_text += "</div>"
  pop_tag('center', token)

def begin_div(token):
  global slides_text
  match = re.match(r'(.*)\[(.*)\]', token.text)
  if match:
    div_class = match.group(1)
    div_attrs = match.group(2)
  else:
    div_class = token.text
    div_attrs = ''
  div_class = re.sub(r'\+', ' ', div_class)
  slides_text += "<div class='%s' %s>" % (div_class, div_attrs)
  push_tag('div', token)

def begin_list(token):
  global slides_text
  if token.text != 'ul' and token.text != 'ol':
    token.complain("Unknown list type: %s" % token.text)
  slides_text += "<%s>" % token.text
  push_tag(token.text, token)

def end_group(token):
  global slides_text
  tag, token = tag_stack[-1]
  if tag == 'div':
    pop_tag('div', token)
    slides_text += "</div>"
  elif tag == 'ul':
    pop_tag('ul', token)
    slides_text += "</ul>"
  elif tag == 'ol':
    pop_tag('ol', token)
    slides_text += "</ol>"
  else:
    token.complain("I see a group closure, but the matching tag is %s at %s(%s)" % (tag, token.filename, token.line)) 

def include_file(token):
  to_from('include', token.text, None)
  process_cy(token.text)

def add_external_script(token):
  global scripts
  scripts.append(token.text)

def insert_media(token):
  global slides_text
  (src, attrs) = re.search('^(\S*)\s*(.*)', token.text).groups(0)
  lower_src = src.lower()
  if '.png' in lower_src:
    tag = 'img'
  elif '.jpeg' in lower_src or '.jpg' in lower_src:
    tag = 'img'
  elif '.svg' in lower_src:
    tag = 'img'
  elif '.mp4' in lower_src:
    tag = 'video'
  else:
    token.complain("Can't determine whether " + src + " is an image or a video.")
  slides_text += "<%s src='%s' %s></%s>" % (tag, src, attrs, tag)

def insert_line_break(token):
  global slides_text
  slides_text += "<br>"

def insert_vertical_space(token):
  global slides_text
  slides_text += "<p>&nbsp;</p>";

def insert_em_dash(token):
  global slides_text
  slides_text += "&mdash;";

def insert_item(token):
  global slides_text
  slides_text += "<li>";

def toggle_bold(token):
  global slides_text, is_bold
  if not is_bold:
    slides_text += '<b>'
    push_tag('b', token)
  else:
    slides_text += '</b>'
    pop_tag('b', token)
  is_bold = not is_bold 
    
def toggle_ital(token):
  global slides_text, is_ital
  if not is_ital:
    slides_text += '<i>'
    push_tag('i', token)
  else:
    slides_text += '</i>'
    pop_tag('i', token)
  is_ital = not is_ital 
    

  

def parse(tokens):
  # Remove the comments first, to make the transition table simpler.
  tokens = filter(lambda x: x.tt != TT.comment, tokens)

  # Parse the input using a transition table keyed state/token-type pairs.
  # Each maps to a next state and a function to handle that token.
  #
  # Read thusly: (current state, token type)  : (function to call, next state)
  #
  transitions = {
    # Major mode transitions.
    (S.initial, TT.config)  : (None, S.config),
    (S.initial, TT.style)   : (None, S.style),
    (S.initial, TT.slides)  : (None, S.slides),
    (S.initial, TT.script)  : (None, S.script),

    (S.config,  TT.style)   : (None, S.style),
    (S.config,  TT.slides)  : (None, S.slides),
    (S.config,  TT.script)  : (None, S.script),

    (S.style,   TT.config)  : (None, S.config),
    (S.style,   TT.slides)  : (None, S.slides),
    (S.style,   TT.script)  : (None, S.script),
    
    (S.slides,  TT.config)  : (None, S.config),
    (S.slides,  TT.style)   : (None, S.style),
    (S.slides,  TT.script)  : (None, S.script),

    (S.script,  TT.config)  : (None, S.config),
    (S.script,  TT.style)   : (None, S.style),
    (S.script,  TT.slides)  : (None, S.slides),

    # Outside of the slides section, closing braces, line breaks, and math
    # delimiters don't need any special treatment.
    (S.config, TT.end_group) : (lambda token: append_to_config(Token(TT.character, '}', token.filename, token.line)), S.config),
    (S.style,  TT.end_group) : (lambda token: append_to_style(Token(TT.character, '}', token.filename, token.line)), S.style),
    (S.script, TT.end_group) : (lambda token: append_to_script(Token(TT.character, '}', token.filename, token.line)), S.script),

    (S.config, TT.line_break) : (lambda token: append_to_config(Token(TT.character, '\\\\', token.filename, token.line)), S.config),
    (S.style,  TT.line_break) : (lambda token: append_to_style(Token(TT.character, '\\\\', token.filename, token.line)), S.style),
    (S.script, TT.line_break) : (lambda token: append_to_script(Token(TT.character, '\\\\', token.filename, token.line)), S.script),

    (S.config, TT.inline_math) : (lambda token: append_to_config(Token(TT.character, '$', token.filename, token.line)), S.config),
    (S.style,  TT.inline_math) : (lambda token: append_to_style(Token(TT.character, '$', token.filename, token.line)), S.style),
    (S.script, TT.inline_math) : (lambda token: append_to_script(Token(TT.character, '$', token.filename, token.line)), S.script),

    # Raw characters and newlines are usually just added to the appropriate
    # section.
    (S.initial, TT.newline)    : (None, S.initial),

    (S.config,  TT.newline)    : (append_to_config, S.config),
    (S.config,  TT.character)  : (append_to_config, S.config),

    (S.style,  TT.newline)     : (append_to_style, S.style),
    (S.style,  TT.character)   : (append_to_style, S.style),

    (S.script,  TT.newline)     : (append_to_script, S.script),
    (S.script,  TT.character)   : (append_to_script, S.script),


    (S.slides, TT.newline)     : (append_to_slides, S.slides),

    (S.in_slide, TT.newline)   : (append_to_slides, S.in_slide),
    (S.in_slide, TT.character) : (append_to_slides, S.in_slide),

    # Within slides, switch into and out of math mode.
    (S.in_slide, TT.inline_math) : (append_to_slides, S.in_inline_math),

    (S.in_inline_math, TT.inline_math) : (append_to_slides, S.in_slide),

    # Includes and external scripts are allowed anywhere except in a slide.
    (S.initial, TT.include) : (include_file, S.initial),
    (S.config,  TT.include) : (include_file, S.config),
    (S.style,   TT.include) : (include_file, S.style),
    (S.script,  TT.include) : (include_file, S.script),
    (S.slides,  TT.include) : (include_file, S.slides),

    (S.initial, TT.external_script) : (add_external_script, S.initial),
    (S.config,  TT.external_script) : (add_external_script, S.config),
    (S.style,   TT.external_script) : (add_external_script, S.style),
    (S.script,  TT.external_script) : (add_external_script, S.script),
    (S.slides,  TT.external_script) : (add_external_script, S.slides),


    # The slides section should begin with a slide title.
    (S.slides, TT.slide_title) : (begin_slide, S.in_slide),

    # When we see the next title, start a new slide.
    (S.in_slide, TT.slide_title) : (end_and_begin_slide, S.in_slide),

    # Some HTML shortcuts for slide contents.
    (S.in_slide, TT.begin_center)   : (begin_center,          S.in_slide),
    (S.in_slide, TT.end_center)     : (end_center,            S.in_slide),
    (S.in_slide, TT.begin_div)      : (begin_div,             S.in_slide),
    (S.in_slide, TT.begin_list)     : (begin_list,            S.in_slide),
    (S.in_slide, TT.end_group)      : (end_group,             S.in_slide),
    (S.in_slide, TT.media)          : (insert_media,          S.in_slide),
    (S.in_slide, TT.line_break)     : (insert_line_break,     S.in_slide),
    (S.in_slide, TT.item)           : (insert_item,           S.in_slide),
    (S.in_slide, TT.vertical_space) : (insert_vertical_space, S.in_slide),
    (S.in_slide, TT.em_dash)        : (insert_em_dash,        S.in_slide),
    (S.in_slide, TT.bold)           : (toggle_bold,           S.in_slide),
    (S.in_slide, TT.ital)           : (toggle_ital,           S.in_slide),

    (S.in_slide, TT.start)          : (set_start_slide,       S.in_slide)
  }

  # The math state is just like the in_slide state, except that we treat } as
  # just a character, instead of as a group close.  Adding these separately
  # here to keep from duplicating everything.
  for ((state, token), (func, next_state)) in transitions.items():
    if state == S.in_slide and next_state == S.in_slide:
      if token == TT.end_group:
        transitions[(S.in_inline_math, token)] = (append_to_slides, S.in_inline_math)
      else:
        transitions[(S.in_inline_math, token)] = (func, S.in_inline_math)

  # Actually process the token stream.
  state = S.initial

  global tag_stack
  tag_stack = list()
  for token in tokens:
    try:
      (func, next_state) = transitions[state, token.tt]
    except KeyError:
      token.complain('Did not expect a %s (%s) in %s state.' % (token.tt, token.text, state))
    if func:
      func(token)
    state = next_state
  
  # Some states have cleanup that should happen if we terminate in them.  An
  # None entry in the table means that terminating here is OK, but there's
  # nothing to do.
  cleanup = {
    S.config : None,
    S.style : None,
    S.script : None,
    S.in_slide : end_slide,
  }

  try:
    cleanup_func = cleanup[state]
  except KeyError:
    complain('Did not expect end-of-file in %s state.' % (state))
  if cleanup_func:
    cleanup_func()
  
  if tag_stack:
    tag, token = tag_stack.pop()
    token.complain("Unclosed %s tag." % tag)

  # All done.  Nothing to return here -- the work is done by appending things
  # to the *_text variables.
  pass

def render(source_file):
  return '''
  <!-- Generated by cyflwyniad from %s on %s. -->
  <html>
    <head>
      <link rel='stylesheet' href="http://rawgit.com/hakimel/reveal.js/3.3.0/css/reveal.css">
      <style>
        %s
      </style>
    </head> 
    <body>
      <div class=reveal>
        <div class=slides>
          %s
        </div>
      </div>
    </body>
    <script src="http://rawgit.com/hakimel/reveal.js/3.3.0/js/reveal.js"></script>
    %s
    <script>
      
      %s

      Reveal.initialize({
        %s
      });
      Reveal.slide( %s );
    </script>
  </html>
''' % (
    source_file,
    time.strftime("%c"),
    style_text,
    slides_text,
    "\n".join(map(lambda x: "<script src='%s'></script>" % x, scripts)),
    script_text,
    config_text,
    start_slide_number
  )


def process_cy(input_filename):

  # Split into tokens.
  tokens = lex(input_filename, x)
  #print "\n".join(map(str, tokens))

  # Convert the token list into the actual HTML text that we want.  This adds
  # to *_text as a side effect.
  parse(tokens)

  # Build the HTML page based on these components.
  html = render(args.input_filename)

  # If we're in offline mode or onefile mode, make the appropriate
  # transformations.
  if args.onefile:
    html = hunangynhwysol.expand_onefile_text(html)
  if args.offline:
    datgysylltu.init(args.job_name + '-files')
    html = datgysylltu.expand_text(args.output_filename, html)
    datgysylltu.done()

  # Save the rendered page.
  to_from('final output', None, args.output_filename)

  if args.output_filename != '-':
    f = open(args.output_filename, 'w')
  else:
    f = sys.stdout
  print >>f, html
  if args.output_filename != '-':
    f.close()


