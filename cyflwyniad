#!/usr/bin/env python

# This program generates HTML presentations based in reveal.js, from a certain
# custom input format.

import argparse
import re
import sys
import htmlmin
from bs4 import BeautifulSoup

# Token Types.
class TT:
  comment = 'comment'
  config = 'config'
  style = 'style'
  slides = 'slides'
  slide_title = 'slide title'
  newline = 'newline'
  character = 'simple character'
  include = 'include directive'
  plugin = 'plugin directive'
  begin_center = 'begin_centering'
  end_center = 'end_centering'
  begin_div = 'begin div'
  end_div = 'end div'
  media = 'media'
  line_break = 'line break'
  bold = 'bold'
  ital = 'italics'
  vertical_space = 'vertical space'

# Parser states.
class S:
  initial = 'initial' # The initial state.  Next should be a major section heading.
  config = 'config'   # Configuration for reveal.js.  Just raw characters.
  style = 'style'     # Top-level CSS.  Just raw characters.
  slides = 'slides'   # At the start of a slides section.  Need a slide title next.
  in_slide = 'inside slide' # Ready for the content of a slide.

# A token class.  Mainly useful because it can keep track of a location in the
# input file, for error messages.
class Token:
  def __init__(self, _tt, _text, _filename, _line):
    self.tt = _tt
    self.text = _text
    self.filename = _filename
    self.line = _line

  def complain(self, message):
    complain("%s(%d): %s" % (self.filename, self.line, message))

  def __repr__(self):
    return "Token(%s, %s, %s, %s)" % (self.tt.__repr__(), self.text.__repr__(), self.filename.__repr__(), self.line.__repr__())


def complain(message):
  raise Exception(message)


def lex(filename, x):
  # Tokenize the input.  The patterns below are a prioritized list of patterns
  # to search for.  We peel off the first matching pattern, and then repeat
  # until nothing is left.  Each pattern can have a () group, which will become
  # the token text.
  patterns = [
    # (r'(//.*)', TT.comment),
    (r'\[config\]', TT.config),
    (r'\[style\]', TT.style),
    (r'\[slides\]', TT.slides),
    (r'#include (.*)', TT.include),
    (r'#plugin (.*)', TT.plugin),
    (r'#{5,}\s*([^#\n]*?)\s*#{5,}', TT.slide_title),
    (r'\[\[([^\]]*)\]\]', TT.media),
    (r'>>>', TT.begin_center),
    (r'<<<', TT.end_center),
    (r'\\\\', TT.line_break),
    (r'\.\.\.', TT.vertical_space),
    (r'!([a-zA-Z_:=0-9\[\]-]*){', TT.begin_div),
    (r'}', TT.end_div),
    (r'\*\*', TT.bold),
    (r'__', TT.ital),
    (r'(\n+)', TT.newline),
    (r'(.)', TT.character)
  ]

  line = 1
  tokens = list()
  while x:
    for (pattern, tt) in patterns:
      match = re.search('^' + pattern, x)
      if match:
        eaten = match.group(0)
        try:
          token = match.group(1)
        except IndexError:
          token = None
        tokens.append(Token(tt, token, filename, line))
        line += eaten.count('\n')
        x = x[len(eaten):]
        break
  return tokens

# These 
def push_tag(tag, token):
  tag_stack.append((tag, token))

def pop_tag(tag, token):
  (old_tag, old_token) = tag_stack.pop()
  if old_tag != tag:
    token.complain("Closing %s tag mismatches with the opening %s tag from %s(%s)." % (tag, old_tag, old_token.filename, old_token.line))

# These functions are generally used as actions in parse() below.
def append_to_config(token):
  global config_text 
  config_text += token.text

def append_to_style(token):
  global style_text 
  style_text += token.text

def append_to_slides(token):
  global slides_text 
  slides_text += token.text

def begin_slide(token):
  global slides_text
  slides_text += "<section>"
  slides_text += "<h1>" + token.text + "</h1>"
  push_tag("section", token)
  slides_text += "<center><div class=slide-body>"
  push_tag("slide-body", token)

def end_slide(token=None):
  global slides_text
  slides_text += "</div></center>"
  pop_tag('slide-body', token)
  slides_text += "</section>"
  pop_tag('section', token)

def end_and_begin_slide(token):
  end_slide(token)
  begin_slide(token)

def begin_center(token):
  global slides_text
  slides_text += "<div style='text-align: center'>"
  push_tag('center', token)
  
def end_center(token):
  global slides_text
  slides_text += "</div>"
  pop_tag('center', token)

def begin_div(token):
  global slides_text
  match = re.match(r'(.*)\[(.*)\]', token.text)
  if match:
    div_class = match.group(1)
    div_attrs = match.group(2)
  else:
    div_class = token.text
    div_attrs = ''
  slides_text += "<div class=%s %s>" % (div_class, div_attrs)
  push_tag('div', token)

def end_div(token):
  global slides_text
  slides_text += "</div>"
  pop_tag('div', token)

def include_file(token):
  print "+", token.text,
  sys.stdout.flush()
  process_cy(token.text)

def add_plugin(token):
  global plugins
  plugins.append(token.text)

def insert_media(token):
  global slides_text
  (src, attrs) = re.search('^(\S*)\s*(.*)', token.text).groups(0)
  if 'mp4' not in src:
    slides_text += "<img src='%s' %s />" % (src, attrs)
  else:
    slides_text += "<video src='%s' %s />" % (src, attrs)

def insert_line_break(token):
  global slides_text
  slides_text += "<br>"

def insert_vertical_space(token):
  global slides_text
  slides_text += "<p>&nbsp;</p>";

def toggle_bold(token):
  global slides_text, is_bold
  if not is_bold:
    slides_text += '<b>'
    push_tag('b', token)
  else:
    slides_text += '</b>'
    pop_tag('b', token)
  is_bold = not is_bold 
    
def toggle_ital(token):
  global slides_text, is_ital
  if not is_ital:
    slides_text += '<i>'
    push_tag('i', token)
  else:
    slides_text += '</i>'
    pop_tag('i', token)
  is_ital = not is_ital 
    


  

def parse(tokens):
  # Remove the comments first, to make the transition table simpler.
  tokens = filter(lambda x: x.tt != TT.comment, tokens)

  # Parse the input using a transition table keyed state/token-type pairs.
  # Each maps to a next state and a function to handle that token.
  transitions = {
    # Major mode transitions.
    (S.initial, TT.config)  : (None, S.config),
    (S.initial, TT.style)   : (None, S.style),
    (S.initial, TT.slides)  : (None, S.slides),

    (S.config,  TT.style)   : (None, S.style),
    (S.config,  TT.slides)  : (None, S.slides),

    (S.style,   TT.config)  : (None, S.config),
    (S.style,   TT.slides)  : (None, S.slides),
    
    (S.slides,  TT.config)  : (None, S.config),
    (S.slides,  TT.style)   : (None, S.style),

    # Outside of the slides section, closing braces don't need any special
    # treatment.
    (S.config, TT.end_div) : (lambda token: append_to_config(Token(TT.character, '}', token.filename, token.line)), S.config),
    (S.style, TT.end_div)  : (lambda token: append_to_style(Token(TT.character, '}', token.filename, token.line)), S.style),

    # Raw characters and newlines are usually just added to the appropriate
    # section.
    (S.initial, TT.newline)    : (None, S.initial),

    (S.config,  TT.newline)    : (append_to_config, S.config),
    (S.config,  TT.character)  : (append_to_config, S.config),

    (S.style,  TT.newline)     : (append_to_style, S.style),
    (S.style,  TT.character)   : (append_to_style, S.style),

    (S.slides, TT.newline)     : (append_to_slides, S.slides),

    (S.in_slide, TT.newline)   : (append_to_slides, S.in_slide),
    (S.in_slide, TT.character) : (append_to_slides, S.in_slide),


    # Includes and plugins are allowed anywhere except in a slide.
    (S.initial,  TT.include) : (include_file, S.initial),
    (S.config,   TT.include) : (include_file, S.initial),
    (S.style,    TT.include) : (include_file, S.initial),
    (S.slides,   TT.include) : (include_file, S.initial),
    (S.initial,  TT.plugin) : (add_plugin, S.initial),
    (S.config,   TT.plugin) : (add_plugin, S.initial),
    (S.style,    TT.plugin) : (add_plugin, S.initial),
    (S.slides,   TT.plugin) : (add_plugin, S.initial),


    # The slides section should begin with a slide title.
    (S.slides, TT.slide_title) : (begin_slide, S.in_slide),

    # When we see the next title, start a new slide.
    (S.in_slide, TT.slide_title) : (end_and_begin_slide, S.in_slide),

    # Some HTML shortcuts for slide contents.
    (S.in_slide, TT.begin_center)   : (begin_center,          S.in_slide),
    (S.in_slide, TT.end_center)     : (end_center,            S.in_slide),
    (S.in_slide, TT.begin_div)      : (begin_div,             S.in_slide),
    (S.in_slide, TT.end_div)        : (end_div,               S.in_slide),
    (S.in_slide, TT.media)          : (insert_media,          S.in_slide),
    (S.in_slide, TT.line_break)     : (insert_line_break,     S.in_slide),
    (S.in_slide, TT.vertical_space) : (insert_vertical_space, S.in_slide),
    (S.in_slide, TT.bold)           : (toggle_bold,           S.in_slide),
    (S.in_slide, TT.ital)           : (toggle_ital,           S.in_slide),
  }

  # Actually process the token stream.
  state = S.initial

  global tag_stack
  tag_stack = list()
  for token in tokens:
    try:
      (func, next_state) = transitions[state, token.tt]
    except KeyError:
      token.complain('Did not expect a %s (%s) in %s state.' % (token.tt, token.text, state))
    if func:
      func(token)
    state = next_state
  
  # Some states have cleanup that should happen if we terminate in them.  An
  # None entry in the table means that terminating here is OK, but there's
  # nothing to do.
  cleanup = {
    S.style : None,
    S.in_slide : end_slide,
  }

  try:
    cleanup_func = cleanup[state]
  except KeyError:
    complain('Did not expect end-of-file in %s state.' % (state))
  if cleanup_func:
    cleanup_func()
  
  if tag_stack:
    tag, token = tag_stack.pop()
    token.complain("Unclosed %s tag." % tag)

  # All done.  Nothing to return here -- the work is done by appending things
  # to the *_text variables.
  pass

def render():
  return '''
  <html>
    <head>
      <link rel='stylesheet' href="reveal.js-3.3.0/css/reveal.css">
      <style>
        %s
      </style>
    </head> 
    <body>
      <div class=reveal>
        <div class=slides>
          %s
        </div>
      </div>
    </body>
    <script src="reveal.js-3.3.0/js/reveal.js"></script>
    %s
    <script>
      Reveal.initialize({
        %s
      });
    </script>
  </html>
''' % (
    style_text,
    slides_text,
    "\n".join(map(lambda x: "<script src='reveal.js-3.3.0/plugin/%s'></script>" % x, plugins)),
    config_text
  )


def process_cy(input_filename):
  # Read the input file.
  if input_filename != '-':
    f = open(input_filename, 'r')
  else:
    f = sys.stdin
  x = f.read()

  # Split into tokens.
  tokens = lex(input_filename, x)

  # Convert the token list into the actual HTML text that we want.  This adds
  # to *_text as a side effect.
  parse(tokens)

def main():
  # Sort out the command line.
  parser = argparse.ArgumentParser()
  parser.add_argument(dest='input_filename', help='input filename')
  parser.add_argument('--output', '-o', dest='output_filename', help='output filename', default=None)
  args = parser.parse_args()

  # Make sure we have reasonable filenames.
  if not args.output_filename:
    if args.input_filename != '-':
      args.output_filename = re.sub('\.cy$', '.html', args.input_filename)
    else:
      args.output_filename = '-'
  if args.input_filename == args.output_filename and args.input_filename != '-':
    complain('Input and output filenames are the same.')
  
  # The main outcome will be strings to drop into the final HTML file.  Start
  # with nothing.
  global config_text, style_text, slides_text, is_bold, is_ital, plugins
  config_text = ""
  style_text = ""
  slides_text = ""
  is_bold = False
  is_ital = False
  plugins = list()

  # Read and execute the input.
  print args.input_filename,
  sys.stdout.flush()
  process_cy(args.input_filename)

  print "-->", args.output_filename
  sys.stdout.flush()

  # Build the HTML page based on these components.
  html = render()

  # Reduce the HTML size.
  #html = htmlmin.minify(unicode(html),remove_comments=True, reduce_boolean_attributes=True, remove_all_empty_space=True)

  # Make the HTML pretty.
  #html = BeautifulSoup(html, 'lxml').prettify()

  # Save the rendered page.
  if args.output_filename != '-':
    f = open(args.output_filename, 'w')
  else:
    f = sys.stdout
  print >>f, html



if __name__ == '__main__':
  main()

