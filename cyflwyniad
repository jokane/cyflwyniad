#!/usr/bin/env python

# This program generates HTML presentations based in reveal.js, from a certain
# custom input format.

import argparse
import re
import sys
import htmlmin

# Token Types.
class TT:
  comment = 'comment'
  config = 'config'
  style = 'style'
  slides = 'slides'
  slide_title = 'slide title'
  newline = 'newline'
  character = 'simple character'

# Parser states.
class S:
  initial = 'initial' # The initial state.  Next should be a major section heading.
  config = 'config'   # Configuration for reveal.js.  Just raw characters.
  style = 'style'     # Top-level CSS.  Just raw characters.
  slides = 'slides'   # At the start of a slides section.  Need a slide title next.
  in_slide = 'inside slide' # Ready for the content of a slide.


def complain(message):
  raise Exception(message)


def lex(x):
  # Tokenize the input.  The patterns below are a prioritized list of patterns
  # to search for.  We peel off the first matching pattern, and then repeat
  # until nothing is left.  Each pattern can have a () group, which will become
  # the token text.
  patterns = [
    (r'(\n+)', TT.newline),
    (r'(//.*)', TT.comment),
    (r'\[config\]', TT.config),
    (r'\[style\]', TT.style),
    (r'\[slides\]', TT.slides),
    (r'#{5,}\s*([^#]*?)\s*#{5,}', TT.slide_title),
    (r'(.)', TT.character)
  ]

  tokens = list()
  while x:
    for (pattern, tt) in patterns:
      match = re.search('^' + pattern, x)
      if match:
        try:
          token = match.group(1)
        except IndexError:
          token = None
        tokens.append((tt, token))
        x = x[len(match.group(0)):]
        break

  return tokens

def append_to_config(tt, token):
  global config_text 
  config_text += token

def append_to_style(tt, token):
  global style_text 
  style_text += token

def append_to_slides(tt, token):
  global slides_text 
  slides_text += token

def begin_slide(tt, token):
  global slides_text
  slides_text += "<section>"
  slides_text += "<h1>" + token + "</h1>"


def parse(tokens):
  # Remove the comments first, to make the transition table simpler.
  tokens = filter(lambda x: x[0] != TT.comment, tokens)

  # The main outcome will be strings to drop into the final HTML file.
  global config_text, style_text, slides_text
  config_text = ""
  style_text = ""
  slides_text = ""

  # Parse the input using a transition table keyed state/token-type pairs.
  # Each maps to a next state and a function to handle that token.
  transitions = {
    # Major mode transitions.
    (S.initial, TT.config)  : (None, S.config),
    (S.initial, TT.style)   : (None, S.style),
    (S.initial, TT.slides)  : (None, S.slides),

    (S.config,  TT.style)   : (None, S.style),
    (S.config,  TT.slides)  : (None, S.slides),

    (S.style,   TT.config)  : (None, S.config),
    (S.style,   TT.slides)  : (None, S.slides),
    
    (S.slides,  TT.config)  : (None, S.config),
    (S.slides,  TT.style)   : (None, S.style),


    # Raw characters and newlines.
    (S.initial, TT.newline)    : (None, S.initial),

    (S.config , TT.newline)    : (append_to_config, S.config),
    (S.config , TT.character)  : (append_to_config, S.config),

    (S.style , TT.newline)     : (append_to_style, S.style),
    (S.style , TT.character)   : (append_to_style, S.style),

    (S.slides, TT.newline)     : (append_to_slides, S.slides),

    (S.in_slide, TT.newline)   : (append_to_slides, S.in_slide),
    (S.in_slide, TT.character) : (append_to_slides, S.in_slide),

    # The slides section should begin with a slide title.
    (S.slides, TT.slide_title) : (begin_slide, S.in_slide),
  }


  # Decorator for adding functions to the transition table.  We're doing it
  # this way because lambda functions can't have assignments.  (Based on:
  # http://stackoverflow.com/questions/6629876/how-to-make-an-anonymous-function-in-python-without-christening-it)
  def transition_for(state, tt, new_state):
    def x(f):
      transitions[(state, tt)] = (new_state, f)
    return x


  # Actually process the token stream.
  state = S.initial
  for tt, token in tokens:
    try:
      (func, next_state) = transitions[state, tt]
    except KeyError:
      complain('Did not expect a %s (%s) in %s state.' % (tt, token, state))
    if func:
      func(tt, token)
    state = next_state

  return config_text, style_text, slides_text

def render(config_text, style_text, slides_text):
  return '''
  <html>
    <style>
      %s
    </style>
    <body>
      %s
    </body>
    <script>
      %s
    </script>
  </html>
''' % (style_text, slides_text, config_text)



def main():
  # Sort out the command line.
  parser = argparse.ArgumentParser()
  parser.add_argument(dest='input_filename', help='input filename')
  parser.add_argument('--output', '-o', dest='output_filename', help='output filename', default=None)
  args = parser.parse_args()

  # Make sure we have reasonable filenames.
  if not args.output_filename:
    if args.input_filename != '-':
      args.output_filename = re.sub('\.cy$', '.html', args.input_filename)
    else:
      args.output_filename = '-'
  if args.input_filename == args.output_filename and args.input_filename != '-':
    complain('Input and output filenames are the same.')
  
  print >>sys.stderr, args.input_filename, '-->', args.output_filename

  # Read the input file.
  if args.input_filename != '-':
    f = open(args.input_filename, 'r')
  else:
    f = sys.stdin
  x = f.read()

  # Split into tokens.
  tokens = lex(x)

  # Convert the token list into the actual HTML text that we want.
  config_text, style_text, slides_text = parse(tokens)

  # Build the HTML page based on these components.
  html = render(config_text, style_text, slides_text)

  # Reduce the HTML size.
  html = htmlmin.minify(unicode(html),remove_comments=True, reduce_boolean_attributes=True, remove_all_empty_space=True)

  # Save the rendered page.
  if args.output_filename != '-':
    f = open(args.output_filename, 'w')
  else:
    f = sys.stdout
  print >>f, html



if __name__ == '__main__':
  main()
