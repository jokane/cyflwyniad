#!/usr/bin/env python

# This program generates HTML presentations based in reveal.js, from a certain
# custom input format.

import argparse
import re
import sys
import urllib2
import StringIO
import os
import hashlib # For turning URLs into well-behaved filenames.
import time
import subprocess
import mimetypes
import shutil

import datgysylltu
import hunangynhwysol

from common import complain, get_file, to_from, mkdir_if_needed, download_if_needed

# Parser states.
class S:
  initial = 'initial' # The initial state.  Next should be a major section heading.
  config = 'config'   # Configuration for reveal.js.  Just raw characters.
  style = 'style'     # Top-level CSS.  Just raw characters.
  script = 'script'   # A raw script to insert into the page.
  slides = 'slides'   # At the start of a slides section.  Need a slide title next.
  in_slide = 'inside slide' # Ready for the content of a slide.
  in_inline_math = 'inline math'    # Within a slide, inside an inline math nugget.

## Each kind of token is defined by a function like this:
# def token_xxx(x, state, doc):
#   return None
# Does this given string start with this token, and is it appropriate here?
#   If yes, modify the document as appropriate, and return a tuple of the
#    match object and the next state.
#   If no, return None.

def token_style(x, state, doc):
  # Start of a style section.
  match = re.search(r'^\[style\]', x)
  if not match: return None
  return (match, S.style)

def token_config(x, state, doc):
  # Start of a config section.
  match = re.search(r'^\[config\]', x)
  if not match: return None
  return (match, S.config)

def token_slides(x, state, doc):
  # Start of a slides section.
  match = re.search(r'^\[slides\]', x)
  if not match: return None
  return (match, S.slides)

def token_slidetitle(x, state, doc):
  if state != S.slides and state != S.in_slide: return None
  match = re.search(r'^#{3,}\s*([^#\n]*?)\s*#{3,}', x)
  if not match: return None

  doc.slides += "<section>"
  doc.slides += "<h1>" + match.group(1) + "</h1>"
  #TODO push_tag("section", token)
  doc.slides += "<center><div class=slide-body>"
  #TODO push_tag("slide-body", token)
  doc.slide_number += 1

  return (match, S.in_slide)


 
def token_emdash(x, state, doc):
  # Em dash, only inside slides.
  if state != S.in_slide: return None
  match = re.search(r'^---', x)
  if not match: return None
  
  doc.slides += "&mdash;";
  return (match, state)

def token_character(x, state, doc):
  # Last resort: A single character.
  match = re.search(r'^(.)', x, re.DOTALL)
  if not match: return None

  c = match.group(1)
  
  if state == S.style:
    doc.style += c
  elif state == S.config:
    doc.config += c
  elif state == S.slides or state == S.in_slide:
    doc.slides += c
  else:
    complain("Don't know what to do with a character in state %s" % state)

  # TODO: Add this character where it goes.
  return (match, state)



# A list of all of the token functions, ordered by precedence.
tokens = [
  token_style,
  token_config,
  token_slides,
  token_slidetitle,
  token_emdash,
  token_character
]

class Document:
  def __init__(self):
    # These are the components of the document that we'll assemble into the
    # final HTML file.
    self.config = ""
    self.style = ""
    self.script = ""
    self.script_includes = list()
    self.slides = ""
    self.slide_number = 0
    self.start_slide_number = 0
    self.is_bold = False
    self.is_ital = False

  def process_cy(self, input_filename):
    # Read the given input file, append its contents to the current document.
    to_from('cy input', input_filename, None)

    # Check spelling.
    if input_filename != '-':
      ret = subprocess.call(['ispell', '-p', '.ispell_default', input_filename])
      if ret !=0:
        complain(input_filename + ": Failed spell check.")

    # Read the input file.
    if input_filename != '-':
      f = open(input_filename, 'r')
    else:
      f = sys.stdin
    x = f.read()

    # Process this input, one token at a time.
    state = S.initial
    line = 1
    while len(x) > 0:
      for token in tokens:
        # Try this token.
        r = token(x, state, self)
        
        # Did it work?
        if r:
          # Yes.  Remove the matched part from the string.
          (match, new_state) = r
          eaten = match.group(0)
          print "On line %d, in state %s, %s matched %s." % (line, state, token.__name__, eaten.__repr__())
          line += eaten.count('\n')
          state = new_state
          x = x[len(eaten):]

          # Go back to the start of the token list.
          break


  def render(self, source_file_name):
    return '''
    <!-- Generated by cyflwyniad from %s on %s. -->
    <html>
      <head>
        <link rel='stylesheet' href="http://rawgit.com/hakimel/reveal.js/3.3.0/css/reveal.css">
        <style>
          %s
        </style>
      </head> 
      <body>
        <div class=reveal>
          <div class=slides>
            %s
          </div>
        </div>
      </body>
      <script src="http://rawgit.com/hakimel/reveal.js/3.3.0/js/reveal.js"></script>
      %s
      <script>
        
        %s

        Reveal.initialize({
          %s
        });
        Reveal.slide( %s );
      </script>
    </html>
  ''' % (
      source_file_name,
      time.strftime("%c"),
      self.style,
      self.slides,
      "\n".join(map(lambda x: "<script src='%s'></script>" % x, self.script_includes)),
      self.script,
      self.config,
      self.start_slide_number
    )


def main():
  # Sort out the command line.
  global args
  parser = argparse.ArgumentParser()
  parser.add_argument(dest='input_filename', help='input filename')
  parser.add_argument('--output', '-o', dest='output_filename', help='output filename', default=None)
  expand_opts = parser.add_mutually_exclusive_group(required=False)
  expand_opts.add_argument('--offline', dest='offline', help='Try to allow offline viewing by downloading linked files.', action='store_true') 
  expand_opts.add_argument('--onefile', dest='onefile', help='Try make a fully self-contained html file using data URLs.', action='store_true') 
  args = parser.parse_args()

  # Make sure we have reasonable filenames.
  if not args.output_filename:
    if args.input_filename != '-':
      args.output_filename = re.sub('\.cy$', '.html', args.input_filename)
    else:
      args.output_filename = '-'
  if args.input_filename == args.output_filename and args.input_filename != '-':
    complain('Input and output filenames are the same.')
  args.job_name = re.sub('\.cy$', '', args.input_filename)

  # Start with an empty document, then parse the input file.
  doc = Document()
  doc.process_cy(args.input_filename)

  # Build the HTML page based on these components.
  html = doc.render(args.input_filename)

  # Save the rendered page.
  to_from('final output', None, args.output_filename)

  if args.output_filename != '-':
    f = open(args.output_filename, 'w')
  else:
    f = sys.stdout
  print >>f, html
  if args.output_filename != '-':
    f.close()

  # If we're in offline mode or onefile mode, make the appropriate
  # transformations.
  if args.onefile:
    html = hunangynhwysol.expand_onefile_text(html)
  if args.offline:
    datgysylltu.init(args.job_name + '-files')
    html = datgysylltu.expand_text(args.output_filename, html)
    datgysylltu.done()


if __name__ == '__main__':
  main()
