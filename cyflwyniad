#!/usr/bin/env python

# This program generates HTML presentations based in reveal.js, from a certain
# custom input format.

import argparse
import re
import sys
import htmlmin

# Token Types.
class TT:
  comment = 'comment'
  config = 'config'
  style = 'style'
  slides = 'slides'
  slide_title = 'slide title'
  newline = 'newline'
  character = 'simple character'
  include = 'include directive'
  begin_center = 'begin_centering'
  end_center = 'end_centering'
  begin_div = 'begin div'
  end_div = 'end div'

# Parser states.
class S:
  initial = 'initial' # The initial state.  Next should be a major section heading.
  config = 'config'   # Configuration for reveal.js.  Just raw characters.
  style = 'style'     # Top-level CSS.  Just raw characters.
  slides = 'slides'   # At the start of a slides section.  Need a slide title next.
  in_slide = 'inside slide' # Ready for the content of a slide.

# A token class.  Mainly useful because it can keep track of a location in the
# input file, for error messages.
class Token:
  def __init__(self, _tt, _text, _filename, _line):
    self.tt = _tt
    self.text = _text
    self.filename = _filename
    self.line = _line

  def complain(self, message):
    complain("%s(%d): %s" % (self.filename, self.line, message))


def complain(message):
  raise Exception(message)


def lex(filename, x):
  # Tokenize the input.  The patterns below are a prioritized list of patterns
  # to search for.  We peel off the first matching pattern, and then repeat
  # until nothing is left.  Each pattern can have a () group, which will become
  # the token text.
  patterns = [
    (r'(\n+)', TT.newline),
    (r'(//.*)', TT.comment),
    (r'\[config\]', TT.config),
    (r'\[style\]', TT.style),
    (r'\[slides\]', TT.slides),
    (r'#include (.*)', TT.include),
    (r'#{5,}\s*([^#]*?)\s*#{5,}', TT.slide_title),
    (r'-->', TT.begin_center),
    (r'<--', TT.end_center),
    (r'!([a-zA-Z_]*){', TT.begin_div),
    (r'}', TT.end_div),
    (r'(.)', TT.character)
  ]

  line = 1
  tokens = list()
  while x:
    for (pattern, tt) in patterns:
      match = re.search('^' + pattern, x)
      if match:
        eaten = match.group(0)
        try:
          token = match.group(1)
        except IndexError:
          token = None
        tokens.append(Token(tt, token, filename, line))
        line += eaten.count('\n')
        x = x[len(eaten):]
        break

  return tokens

def append_to_config(token):
  global config_text 
  config_text += token.text

def append_to_style(token):
  global style_text 
  style_text += token.text

def append_to_slides(token):
  global slides_text 
  slides_text += token.text

def begin_slide(token):
  global slides_text
  slides_text += "<section>"
  slides_text += "<h1>" + token.text + "</h1>"

def end_slide():
  global slides_text
  slides_text += "</section>"

def end_and_begin_slide(token):
  end_slide()
  begin_slide(tt, token.text)

def begin_center(token):
  global slides_text
  slides_text += "<center>"
  
def end_center(token):
  global slides_text
  slides_text += "</center>"

def include_file(token):
  print "include", token.text
  process_cy(token.text)


def parse(tokens):
  # Remove the comments first, to make the transition table simpler.
  tokens = filter(lambda x: x.tt != TT.comment, tokens)

  # The main outcome will be strings to drop into the final HTML file.
  global config_text, style_text, slides_text
  config_text = ""
  style_text = ""
  slides_text = ""

  # Parse the input using a transition table keyed state/token-type pairs.
  # Each maps to a next state and a function to handle that token.
  transitions = {
    # Major mode transitions.
    (S.initial, TT.config)  : (None, S.config),
    (S.initial, TT.style)   : (None, S.style),
    (S.initial, TT.slides)  : (None, S.slides),

    (S.config,  TT.style)   : (None, S.style),
    (S.config,  TT.slides)  : (None, S.slides),

    (S.style,   TT.config)  : (None, S.config),
    (S.style,   TT.slides)  : (None, S.slides),
    
    (S.slides,  TT.config)  : (None, S.config),
    (S.slides,  TT.style)   : (None, S.style),

    # Outside of the slides section, closing braces don't need any special
    # treatment.
    (S.config, TT.end_div) : (lambda token: append_to_config(Token(TT.character, '}', token.filename, token.line)), S.config),
    (S.style, TT.end_div)  : (lambda token: append_to_config(Token(TT.character, '}', token.filename, token.line)), S.style),

    # Raw characters and newlines are usually just added to the appropriate section.
    (S.initial, TT.newline)    : (None, S.initial),

    (S.config , TT.newline)    : (append_to_config, S.config),
    (S.config , TT.character)  : (append_to_config, S.config),

    (S.style , TT.newline)     : (append_to_style, S.style),
    (S.style , TT.character)   : (append_to_style, S.style),

    (S.slides, TT.newline)     : (append_to_slides, S.slides),

    (S.in_slide, TT.newline)   : (append_to_slides, S.in_slide),
    (S.in_slide, TT.character) : (append_to_slides, S.in_slide),


    # Includes are allowed anywhere.
    (S.initial,  TT.include) : (include_file, S.initial),
    (S.config,   TT.include) : (include_file, S.initial),
    (S.style,    TT.include) : (include_file, S.initial),
    (S.slides,   TT.include) : (include_file, S.initial),
    (S.in_slide, TT.include) : (include_file, S.initial),

    # The slides section should begin with a slide title.
    (S.slides, TT.slide_title) : (begin_slide, S.in_slide),

    # When we see the next title, start a new slide.
    (S.in_slide, TT.slide_title) : (end_and_begin_slide, S.in_slide),

    # Some HTML shortcuts for slide contents.
    (S.in_slide, TT.begin_center) : (begin_center, S.in_slide),
    (S.in_slide, TT.end_center)   : (end_center,   S.in_slide),
  }

  # Actually process the token stream.
  state = S.initial
  for token in tokens:
    try:
      (func, next_state) = transitions[state, token.tt]
    except KeyError:
      token.complain('Did not expect a %s (%s) in %s state.' % (token.tt, token.text, state))
    if func:
      func(token)
    state = next_state
  
  # Some states have cleanup that should happen if we terminate in them.  An
  # None entry in the table means that terminating here is OK, but there's
  # nothing to do.
  cleanup = {
    S.style : None,
    S.in_slide : end_slide,
  }

  try:
    cleanup_func = cleanup[state]
  except KeyError:
    complain('Did not expect end-of-file in %s state.' % (state))
  if cleanup_func:
    cleanup_func()

  # All done.  Nothing to return here -- the work is done by appending things
  # to the *_text variables.
  pass

def render(config_text, style_text, slides_text):
  return '''
  <html>
    <head>
      <link rel='stylesheet' href="reveal.js-3.3.0/css/reveal.css">
      <link rel='stylesheet' href="reveal.js-3.3.0/css/theme/white.css">
      <style>
        %s
      </style>
    </head> 
    <body>
      <div class=reveal>
        <div class=slides>
          %s
        </div>
      </div>
    </body>
    <script src="reveal.js-3.3.0/js/reveal.js"></script>
    <script>
      Reveal.initialize({
        %s
      });
    </script>
  </html>
''' % (style_text, slides_text, config_text)


def process_cy(input_filename):
  # Read the input file.
  if input_filename != '-':
    f = open(input_filename, 'r')
  else:
    f = sys.stdin
  x = f.read()

  # Split into tokens.
  tokens = lex(input_filename, x)

  # Convert the token list into the actual HTML text that we want.  This adds
  # to *_text as a side effect.
  parse(tokens)

def main():
  # Sort out the command line.
  parser = argparse.ArgumentParser()
  parser.add_argument(dest='input_filename', help='input filename')
  parser.add_argument('--output', '-o', dest='output_filename', help='output filename', default=None)
  args = parser.parse_args()

  # Make sure we have reasonable filenames.
  if not args.output_filename:
    if args.input_filename != '-':
      args.output_filename = re.sub('\.cy$', '.html', args.input_filename)
    else:
      args.output_filename = '-'
  if args.input_filename == args.output_filename and args.input_filename != '-':
    complain('Input and output filenames are the same.')
  
  print >>sys.stderr, args.input_filename, '-->', args.output_filename

  # Read and execute the input.
  process_cy(args.input_filename)

  # Build the HTML page based on these components.
  html = render(config_text, style_text, slides_text)

  # Reduce the HTML size.
  #html = htmlmin.minify(unicode(html),remove_comments=True, reduce_boolean_attributes=True, remove_all_empty_space=True)

  # Save the rendered page.
  if args.output_filename != '-':
    f = open(args.output_filename, 'w')
  else:
    f = sys.stdout
  print >>f, html



if __name__ == '__main__':
  main()

